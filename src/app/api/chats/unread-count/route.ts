import { getUserFromRequest } from '@/lib/auth'
import prisma from '@/lib/prisma'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(req: NextRequest) {
	const user = await getUserFromRequest(req)
	if (!user) {
		return NextResponse.json({ error: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 })
	}

	try {
		console.log(
			'üîî –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:',
			user.id
		)

		// –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—á—Ç–µ–Ω–∏—è
		const userData = await prisma.user.findUnique({
			where: { id: user.id },
			select: { lastPrivateMessageReadAt: true },
		})

		// –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
		const unreadPrivateMessages = await prisma.privateMessage.count({
			where: {
				recipientId: user.id,
				NOT: { senderId: user.id }, // –ò—Å–∫–ª—é—á–∞–µ–º —Å–≤–æ–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
				...(userData?.lastPrivateMessageReadAt && {
					createdAt: { gt: userData.lastPrivateMessageReadAt },
				}),
			},
		})

		// –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –∑–∞–¥–∞—á
		// –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –≤—Ä–µ–º–µ–Ω–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—á—Ç–µ–Ω–∏—è
		const userTasks = await prisma.task.findMany({
			where: {
				OR: [{ customerId: user.id }, { executorId: user.id }],
			},
			select: {
				id: true,
				customerId: true,
				executorId: true,
				customerLastReadAt: true,
				executorLastReadAt: true,
			},
		})

		let unreadTaskMessages = 0
		for (const task of userTasks) {
			// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—á—Ç–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
			let lastReadAt: Date | null = null
			if (task.customerId === user.id) {
				lastReadAt = task.customerLastReadAt
			} else if (task.executorId === user.id) {
				lastReadAt = task.executorLastReadAt
			}

			// –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏
			const taskUnreadCount = await prisma.message.count({
				where: {
					taskId: task.id,
					NOT: { senderId: user.id }, // –ò—Å–∫–ª—é—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç —Å–∞–º–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
					...(lastReadAt && {
						createdAt: { gt: lastReadAt },
					}),
				},
			})

			unreadTaskMessages += taskUnreadCount
		}

		const totalUnread = unreadPrivateMessages + unreadTaskMessages

		console.log('üìä –ù–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è:', {
			private: unreadPrivateMessages,
			task: unreadTaskMessages,
			total: totalUnread,
		})

		return NextResponse.json({ unreadCount: totalUnread })
	} catch (error) {
		console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π:', error)
		return NextResponse.json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' }, { status: 500 })
	}
}

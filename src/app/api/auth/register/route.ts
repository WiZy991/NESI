import { NextResponse } from 'next/server'
import bcrypt from 'bcrypt'
import prisma from '@/lib/prisma'
import crypto from 'crypto'
import { sendVerificationEmail } from '@/lib/mail'

export async function POST(req: Request) {
  try {
    const { email, password, fullName, role } = await req.json()

    // üîπ –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
    if (!email?.trim() || !password?.trim() || !fullName?.trim()) {
      return NextResponse.json({ error: '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è' }, { status: 400 })
    }

    // üîπ –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingUser = await prisma.user.findUnique({
      where: { email },
      select: { id: true, verified: true },
    })

    if (existingUser) {
      return NextResponse.json(
        { error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
        { status: 400 }
      )
    }

    // üîπ –•—ç—à–∏—Ä—É–µ–º –ø–∞—Ä–æ–ª—å
    const hashedPassword = await bcrypt.hash(password, 10)

    // üîπ –°–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–µ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ)
    const user = await prisma.user.create({
      data: {
        email: email.toLowerCase(),
        fullName: fullName.trim(),
        password: hashedPassword,
        role,
        verified: false,
      },
      select: { id: true, email: true },
    })

    // üîπ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π)
    const token = crypto.randomBytes(32).toString('hex')
    const expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24) // 24 —á–∞—Å–∞

    // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –æ—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ–∫–µ–Ω—ã, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –µ—Å—Ç—å
    await prisma.emailVerificationToken.deleteMany({
      where: { userId: user.id },
    })

    await prisma.emailVerificationToken.create({
      data: {
        userId: user.id,
        token,
        expiresAt,
      },
    })

    // üîπ –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    const verifyLink = `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/verify-email?token=${token}`

    // üîπ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∏—Å—å–º–æ
    await sendVerificationEmail(user.email, verifyLink)

    // üîπ –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    return NextResponse.json({
      message:
        '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ—á—Ç—É –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∞–∫–∫–∞—É–Ω—Ç–∞.',
    })
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error)

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∞—Å—Ç—ã—Ö –æ—à–∏–±–æ–∫ Prisma
    if (error.code === 'P2002') {
      return NextResponse.json(
        { error: '–¢–∞–∫–æ–π email —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω' },
        { status: 400 }
      )
    }

    return NextResponse.json({ error: '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏' }, { status: 500 })
  }
}
